#! /usr/bin/env python

import sys

def main(): 
    #
    # Imports
    #
    import metadata
    import time
    from seqdata import BarcodeClusterer
    from misc import Progress
    import multiprocessing
    import sqlite3
    import json, ast
    import os

    #
    # check input and get commandline args
    #
    try:
        analysisfolder = metadata.AnalysisFolder(sys.argv[1])
        analysisfolder.readindexTsv()
        if analysisfolder.settings.temp: analysisfolder.copy_to_temp()

    except IndexError: sys.stderr.write('please supply a commandline on format:\n'+os.path.basename(__file__)+' <analysis-output-folder>\n');sys.exit()

    #
    # check analysis folder
    #
    if not analysisfolder.checkIntegrity() == 'PASS': print analysisfolder.checkIntegrity()+'\nERROR: Now exiting'

    #
    # create a logfile
    #
    logfile = open(analysisfolder.logpath+'/'+time.strftime("%y%m%d-%H:%M:%S",time.localtime())+'_find_alleles.log.txt','w',1)
    logfile.write('cmd: '+' '.join(sys.argv)+'\n')
    analysisfolder.logfile = logfile

    #
    # check if the target region bedfile is defined
    #
    if not analysisfolder.settings.targetRegionBed or not os.path.exists(analysisfolder.settings.targetRegionBed):
        msg = 'WARNING: cant find the target definition bed file!!\n'
        msg+= '(If run is not targeted you can safely ignore this message).\n'
        sys.stderr.write(msg);
        logfile.write(msg)
     
    #
    # Do the work here!!
    #
    app = ClusterAllelComparer(analysisfolder)
    app.run()
    
    if analysisfolder.database_in_temp: analysisfolder.copy_from_temp()
        
    logfile.write('find_alleles FINISHED\n')

class ClusterAllelComparer():
    """ comparison machine for looking identifying, comparing and finiding support for alleles in the data """
    
    def __init__(self,analysisfolder):
        
        # set conectionn to the analysisfolder
        self.analysisfolder = analysisfolder
        
        # define initial values for variables to be used later
        self.high_qualitty_cluster_ids = None # list for holding the ids of high quality clusters
        self.high_qualitty_barcode_clusters = []
        self.potential_seed_clusters = [] # barcode clusters with full target coverage that will be used as potential seeds for allele clusters

    def run(self):
        self.statistic_position_analysis(range(1000))
        self.find_high_quality_clusters()
        self.load_HQ_clusters()
        self.add_high_quality_heterozygous_clusters()
        self.build_allele_representation_dict_for_HQ_clusters()
        self.find_unique_allales_among_HQ_clusters()
        self.cluster_uniq_HQ_alleles()
        self.find_support_for_alleles()
        self.report()
        #self.statistic_graph_report()

    def statistic_position_analysis(self, cluster_list):
        """
            Function that returns the number of clusters without sequence information, with non reference base and with a heterozygous variant
            for all reference positions from start of first targeted region to end of last
        """
        
        #
        # imports
        #
        import re
        from seqdata import BarcodeCluster
        
        #
        # check if the cluster_list is a list of clusters or a list of cluster ids and convert to list of barcode cluster objects
        #
        if type(cluster_list[0]) == int or (type(cluster_list[0])==str and re.match('^[0-9]+$',cluster_list[0])):
            tmp_list = []
            for clusterID in cluster_list:
                tmp_list.append( BarcodeCluster(int(clusterID), self.analysisfolder) )
            for cluster in tmp_list: cluster.loadClusterInfo()
            cluster_list = tmp_list

        #
        # build the list of reference positions to include
        #
        tmp_reference_positions = []
        tmp_cluster = cluster_list[0]
        if not tmp_cluster.targetInfo: # if the cluster has not been analyzed before
            tmp_cluster.analyze(createBamIndex=True)
            tmp_cluster.findTargetCoverage()
            tmp_cluster.findHetroZygousBasesInTarget()
            tmp_cluster.updatedb()
        last_exon_end = min([entry['start_position'] for entry in tmp_cluster.targetInfo])-50
        for entry in tmp_cluster.targetInfo:
            for tmp_position in xrange(last_exon_end,entry['end_position']): tmp_reference_positions.append(tmp_position)
            #for tmp_position in xrange(entry['start_position'],entry['end_position']): tmp_reference_positions.append(tmp_position)
            last_exon_end = entry['end_position']

        #
        # create output objects
        #
        output_json = {
            'reference_positions':tmp_reference_positions,
            'non_reference_positions':{ position:0 for position in tmp_reference_positions },
            'missing_data_positions':{ position:0 for position in tmp_reference_positions },
            'hetrozygous_positions':{ position:0 for position in tmp_reference_positions },
            'total_clusters':0
        }

        #
        # for backwards compability
        #
        non_reference_positions = { position:0 for position in tmp_reference_positions }
        missing_data_positions  = { position:0 for position in tmp_reference_positions }
        hetrozygous_positions   = { position:0 for position in tmp_reference_positions }
        total_clusters          = 0

        #
        # count the number of clusters at each position
        #
        for cluster in cluster_list:

            # if the cluster has not been analyzed before do it now
            if not cluster.targetInfo:
                cluster.analyze(createBamIndex=True)
                cluster.findTargetCoverage()
                cluster.findHetroZygousBasesInTarget()
                cluster.updatedb()

            # count each type of position
            total_clusters += 1
            output_json['total_clusters'] += 1
            for entry in cluster.targetInfo:
                for position in xrange(entry['start_position'],entry['end_position']):
                    if position in entry['hetrozygous_positions']:
                        hetrozygous_positions[position] += 1
                        output_json['hetrozygous_positions'][position] += 1
                    if position in entry['non_reference_positions']:
                        non_reference_positions[position] += 1
                        output_json['non_reference_positions'][position] += 1
                    if position in entry['missing_data']:
                        missing_data_positions[position] += 1
                        output_json['missing_data_positions'][position] += 1


        #
        # for backwards compability
        #
        self.statistic_position_info = []
        self.statistic_position_info.append(tmp_reference_positions)
        self.statistic_position_info.append(hetrozygous_positions)                        
        self.statistic_position_info.append(non_reference_positions)
        self.statistic_position_info.append(missing_data_positions)
        self.statistic_position_info.append(total_clusters)

        return output_json

    def find_high_quality_clusters(self, ):
        """ function that finds clusters with high quality alleles in the data """

        # connect to database and extract cluster ids for clusters with high quality data
        # defined as having no more than 3 hetrozygous position and having coverage over cutoff for all targeted bases
        self.analysisfolder.database.getConnection()
        tmp_high_qualitty_cluster_ids = self.analysisfolder.database.c.execute('SELECT clusterId FROM barcodeClusters WHERE hetrozygous_positions<=0 AND high_quality_cluster=1').fetchall()
                 
        # reformat the list of ids
        self.high_qualitty_cluster_ids = [int(tmp_info[0]) for tmp_info in tmp_high_qualitty_cluster_ids]
        
        import sys
        if len(self.high_qualitty_cluster_ids) == 0: sys.stderr.write('WARNING: no highquality clusters found.\n')

    def load_HQ_clusters(self,):
        """ Loading the high quality clusters"""
        
        from seqdata import BarcodeCluster
        
        for idnumber in self.high_qualitty_cluster_ids:
            
            cluster = BarcodeCluster(idnumber, self.analysisfolder)
            self.high_qualitty_barcode_clusters.append(cluster)
            cluster.loadClusterInfo()

    def build_allele_representation_dict_for_HQ_clusters(self,):
        """ Function find the high quality cluster information"""
        import operator
        
        #find high quality cluster information
        for cluster in self.high_qualitty_barcode_clusters:
            self.build_allele_representation_dict_for_cluster(cluster)

    def build_allele_representation_dict_for_cluster(self,cluster,reanalyze=False):
        """ Build the allele representation """
        
        # make a dictuionary for positions with highest base 
        intresting_postitions = {}
        if reanalyze:
            cluster.analyze(createBamIndex=True)
            cluster.findTargetCoverage()
            if cluster.targetInfo != []: cluster.findHetroZygousBasesInTarget(include_hetro=True,include_homo_reference=False,include_homo_non_reference=True)
            cluster.removeAllFiles()
        cluster.missing_postitions = []
        for entry in cluster.targetInfo:
            
            #if 'no_coverage' in entry and entry ['no_coverage'] == True: print entry['entry_name'],'has no coverage ie is lost'
            #if 'complete_coverage' in entry and entry['complete_coverage']==True: print entry['entry_name'],'is complete has no missing positions'
            
            try: cluster.missing_postitions += entry['missing_data'].keys()
            except KeyError: pass
            
            # check the distribution of bases at the position and which base is most frequent
            for position,information in entry['non_reference_positions'].iteritems():
                
                #### Attention; this part mybe needed some changes which if we had orginal base and insertion, have to be count base and inserted base at the same time!!!!! 
                most_frequent_base = (None,0)
                #print information
                try:
                    for base, count in information['bases'].iteritems(): 
                    # check the highest frequent base in the position
                
                        if count > most_frequent_base[1] and base != 'lowBQ': most_frequent_base = (base, count)
                
                except KeyError:
                    for base, count in information['insertions'].iteritems():
                         if count > most_frequent_base[1] and base != 'InsertlowBQ': most_frequent_base = (base, count)
                intresting_postitions[position] = most_frequent_base[0]
                    
        intresting_postitions[0] = "X" # dummy position to catch 100% referencce alleles
        # save allele representation as dictionary linked to cluster
        cluster.allele_representation_dict = intresting_postitions
        # print 'positions missing in cluster',cluster.id,'=',cluster.missing_postitions
        pass

    def find_unique_allales_among_HQ_clusters(self,):
        """ Finding unique alleles with high quality clusters"""
        import operator
        
        self.unique_alleles = {}
        
        #    
        # find clusters with identical alllels
        #
        for cluster in self.high_qualitty_barcode_clusters:
            allele_representation_string = '|'.join([str(position)+'='+base for position, base in sorted(cluster.allele_representation_dict.iteritems(), key=operator.itemgetter(0))])
            #print cluster.id, allele_representation_string
            try:
                self.unique_alleles[allele_representation_string].append(cluster)
            except KeyError:
                self.unique_alleles[allele_representation_string] = [cluster]
            
        #
        # sort the identical alleles by count
        #
        self.unique_alleles_by_count = {}
        for allele_representation_string, cluster_list in self.unique_alleles.iteritems(): self.unique_alleles_by_count[allele_representation_string] = len(cluster_list)
        for allele_representation_string, length_of_cluster_id_list in sorted(self.unique_alleles_by_count.iteritems(), key=operator.itemgetter(1), reverse=True):
            cluster_list = self.unique_alleles[allele_representation_string]
            if self.analysisfolder.settings.debug: print '\nThe allele is supported by', length_of_cluster_id_list,'cluster (', cluster_id_list,')\nallelerepstring="',allele_representation_string,'"'
        #
        # Make a dictionary for allleles
        #
        self.alleles = {}
        tmp_allele_counter = 0
        
        #
        # find all positions where an variation was detected in atleast one barcode_cluster
        #
        self.variable_positions_in_at_least_one_barcode_cluster = {}
        for barcode_cluster in self.high_qualitty_barcode_clusters:
            for position in barcode_cluster.allele_representation_dict.keys():
                self.variable_positions_in_at_least_one_barcode_cluster[position] = True
        
        #
        # print table for manual check during development
        #
        print '######### unique alleles'
        print 'id\pos\t'+'\t'.join([str(position) for position in self.variable_positions_in_at_least_one_barcode_cluster])+'\tIDs' # prints the header
        
        #for barcode_cluster in self.high_qualitty_barcode_clusters:
        barcode_clusters_to_compare = []
        self.alleles_sorted_by_barcode_cluster_count = []
        for allele_representation_string, length_of_barcode_cluster_id_list in sorted(self.unique_alleles_by_count.iteritems(), key=operator.itemgetter(1), reverse=True):
            
            # counter to create a unique allele id
            tmp_allele_counter += 1
            
            # get the list of  barcode_clusters with identical alleles
            barcode_cluster_list = self.unique_alleles[allele_representation_string]
            
            # get a representative barcode_cluster to compare always choose first one in the list, could later be changed to the one with highest read count
            barcode_cluster = barcode_cluster_list[0]
            barcode_clusters_to_compare.append(barcode_cluster) # to know barcode_cluster to compare later maybe not needed anymore?
            
            #dictionary for candidate alleles
            this_allele = {
                        'id':tmp_allele_counter,
                        'seeding_barcode_cluster':barcode_cluster_list[0], # representative for original uniuqe allele
                        # 'barcode_clusters_by_difference':{0:barcode_cluster_list}, # all barcode_clusters soreted by difference to the seed
                        'total_barcode_cluster_count':len(barcode_cluster_list), # total number of barcode_clusters supporting this allele
                        'barcode_clusters':barcode_cluster_list, # list of all barcode_clusters supporting this allele
                        'this_allele_clustered_to':None,
                        'added_to_allele_cluster_at_iteration':None,
                        'recruited_by':None,
                        'missmatches_to_seed':0,
                        'has_recruited':[]
                    }
            
            # save this allele to a dictionary and a list
            self.alleles[tmp_allele_counter] = this_allele
            self.alleles_sorted_by_barcode_cluster_count.append(self.alleles[tmp_allele_counter])
            
            # print some info START
            #print ','.join([str(tmp_barcode_cluster.id) for tmp_barcode_cluster in barcode_cluster_list])+'\t',
            #print this_allele['id'],str(len(barcode_cluster_list))+'\t',
            print str(this_allele['id'])+'\t',
            
            #print the positions for alleles
            for position in self.variable_positions_in_at_least_one_barcode_cluster:
                try:
                    print barcode_cluster.allele_representation_dict[position],'\t',
                except KeyError:
                    print '*','\t',
            print ','.join([str(tmp_barcode_cluster.id) for tmp_barcode_cluster in sorted(barcode_cluster_list)])#+'\t'
            # print some END
        print ''
        print '######### unique alleles end'

    def cluster_uniq_HQ_alleles(self, number_of_errors_allowed = 1):
        """ This functions makes Seed alleles as dictionary and clustering them with some analysis for each cluster, also at the end of this function base on the seed allels for some clusters which have diferences in only one positions, making of clusters called Recruiters for supporting of Seed allels would be done"""
        
        import operator
        
        #
        #Dictionary for clustering alleles
        #
        self.allele_clusters = {}
        
        tmp_allele_cluster_counter = 0
        import itertools
        
        # finding seed alleles and print them
        for seed_allele in self.alleles_sorted_by_barcode_cluster_count:
            
            #print '\nlooking at potential seed with id=',seed_allele['id']
            
            #print the seed allels and already clustred alleles
            if seed_allele['this_allele_clustered_to'] != None:
                #print 'seed',seed_allele['id'],'is already clustered to',seed_allele['this_allele_clustered_to'],'continuing with next seed'
                continue
            else:
                tmp_allele_cluster_counter += 1                
                
                #print '# creating allelecluster',tmp_allele_cluster_counter,'around allele',seed_allele['id'],'as seed'
                
                #
                # dictionary for alleles which can be clustered with seed alllels 
                #
                allele_cluster = {
                    'id':tmp_allele_cluster_counter,
                    'seed_for_this_allele_cluster':seed_allele,
                    'alles_in_this_cluster':{seed_allele['id']:seed_allele}, # new barcode_clusters added since last iteration of "allele barcode_clustering"
                    'new_clusters_since_last_iteration':[seed_allele],
                    'iteration':0,
                    'barcode_clusters_in_this_allele_cluster':[barcode_cluster for barcode_cluster in seed_allele['barcode_clusters']],
                    'network':{}
                }
                seed_allele['this_allele_clustered_to'] = tmp_allele_cluster_counter
                seed_allele['added_to_allele_cluster_at_iteration'] = 0
                
                while allele_cluster['new_clusters_since_last_iteration']:
                    
                    allele_cluster['iteration'] += 1
                    recruiters = allele_cluster['new_clusters_since_last_iteration']
                    allele_cluster['new_clusters_since_last_iteration'] = []
                    #print '|------Starting iteration',allele_cluster['iteration'],'for allele cluster',allele_cluster['id'],'using alleles',','.join([str(recruiter['id']) for recruiter in recruiters]),'as recruiters'
                    if allele_cluster['iteration'] >= 5: print 'WARNING!!!! now starting iteration',allele_cluster['iteration'],'for cluster',allele_cluster['id']
                    
                    for recruiter_allele in recruiters:
                        #print '|  |---current recruiter',recruiter_allele['id'],' comparing to all potential candidates'
                                                
                        for candidate_allele in self.alleles_sorted_by_barcode_cluster_count:
                            #print '|  |   |---comparing recruiter',recruiter_allele['id'],'to candidate with id',candidate_allele['id']
                            
                            if recruiter_allele == candidate_allele:
                                #print '|  |   |   \---recruiter and candidate are same (',recruiter_allele['id'],'==',candidate_allele['id'],'), allele cannot recruit itself to cluster, continuing with next candidate'
                                continue
                            
                            if candidate_allele['this_allele_clustered_to'] != None:
                                #print '|  |   |   \---candidate',candidate_allele['id'],'is already clustered to',candidate_allele['this_allele_clustered_to'],', a candidate cannot be recruited twice, continuing with next candidate'
                                continue
                            
                            number_variable_positions, difference_to_seed, missing_position_count, same_variant_count,both_reference_count = self.compare_allele_representation( recruiter_allele['seeding_barcode_cluster'], candidate_allele['seeding_barcode_cluster'] )
                            
                            if difference_to_seed <= 1 : # make to a setting!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                #print '|  |   |   \---recruiter',recruiter_allele['id'],'and candidate',candidate_allele['id'],'have',difference_to_seed,'differences between them we therefore add',candidate_allele['id'],'to allele cluster',allele_cluster['id']
                                
                                allele_cluster['alles_in_this_cluster'][candidate_allele['id']] = candidate_allele
                                allele_cluster['new_clusters_since_last_iteration'].append(candidate_allele)
                                allele_cluster['barcode_clusters_in_this_allele_cluster'] += candidate_allele['barcode_clusters']
                                allele_cluster['network']

                                candidate_allele['added_to_allele_cluster_at_iteration'] = allele_cluster['iteration']
                                candidate_allele['this_allele_clustered_to'] = allele_cluster['id']
                                candidate_allele['recruited_by'] = recruiter_allele['id']
                                candidate_allele['missmatches_to_seed'] = self.compare_allele_representation(seed_allele['seeding_barcode_cluster'], candidate_allele['seeding_barcode_cluster'])
                                recruiter_allele['has_recruited'].append( candidate_allele )
                            else:
                                #print '|  |   |   \---recruiter',recruiter_allele['id'],'and candidate',candidate_allele['id'],'have',difference_to_seed,'differences between more than our cutoff'
                                continue
                        #print'|  |   \--- Recruiter',recruiter_allele['id'],' complete'
                            
                    #print '|  \iteration complete!'
                    #print'|'
                #print'\-cluster complete after',allele_cluster['iteration'],'iterations'
                
            self.allele_clusters[allele_cluster['id']] = allele_cluster

        #print ''
        print '######### allele clusters\n'
        for allele_cluster in self.allele_clusters.values():
            #print str(allele_cluster['id'])+'\tallele\t'+'\t'.join([str(position) for position in self.variable_positions_in_at_least_one_barcode_cluster])+'\tIDs' # prints the header
            for this_allele in allele_cluster['alles_in_this_cluster'].values():
                #print'|-'+str(this_allele['added_to_allele_cluster_at_iteration'])+'\t'+str(this_allele['id'])+'\t',
                for position in self.variable_positions_in_at_least_one_barcode_cluster:
                    try:
                        if position in allele_cluster['seed_for_this_allele_cluster']['seeding_barcode_cluster'].allele_representation_dict and this_allele['seeding_barcode_cluster'].allele_representation_dict[position] == allele_cluster['seed_for_this_allele_cluster']['seeding_barcode_cluster'].allele_representation_dict[position]:
                            #print this_allele['seeding_barcode_cluster'].allele_representation_dict[position],'\t',
                            continue
                        else:
                            continue
                            # RED = "\033[1;91m"
                            # COLOR_STOP = "\033[0m"
                            # print RED+this_allele['seeding_barcode_cluster'].allele_representation_dict[position]+COLOR_STOP,'\t',
                            continue
                    except KeyError:
                        #print'*','\t',
                        continue
                #print','.join([str(tmp_barcode_cluster.id) for tmp_barcode_cluster in this_allele['barcode_clusters']])+'\t'
                continue
            #print''
        print '######### allele clustering done'

    def compare_allele_representation(self,cluster1,cluster2,dont_count_missing=True):

        ''' NOW comparing only known variable positions in the highQ clusters, maybe include the private varaianles between the two clusters aswell these could be PCR errors
            in that case we would need to add some variable tracking those like the variable_positions_in_at_least_one_cluster dict above but not overlapping with the self.variable_positions_in_at_least_one_barcode_cluster dict
            variable_positions_in_at_least_one_cluster = self.variable_positions_in_at_least_one_barcode_cluster.'''
        
        import misc

        variable_positions_in_at_least_one_cluster = {}
        for cluster in [cluster1,cluster2]:
             for position in cluster.allele_representation_dict.keys(): variable_positions_in_at_least_one_cluster[position] = True
        
        for position in self.variable_positions_in_at_least_one_barcode_cluster: variable_positions_in_at_least_one_cluster[position] = True

        #
        # print table for manual check during development
        #
        #print '\t'+'\t'.join([str(position) for position in variable_positions_in_at_least_one_cluster])
        #clusters_to_compare = []
        # for allele_representation_string, length_of_cluster_id_list in sorted(self.unique_alleles_by_count.iteritems(), key=operator.itemgetter(1), reverse=True):
        #for cluster in [cluster1,cluster2]:
            #cluster_list = self.unique_alleles[allele_representation_string]
            #cluster = cluster_list[0]
            #clusters_to_compare.append(cluster)
            #print ','.join([str(tmp_cluster.id) for tmp_cluster in cluster_list])+'\t',
            #print str(cluster.id)+'\t',
            #for position in variable_positions_in_at_least_one_cluster:
                #try:
                    #print cluster.allele_representation_dict[position],'\t',
                #except KeyError:
                    #print '*','\t',
            #print ''
        #print len(variable_positions_in_at_least_one_cluster)
        
        non_equal_position_count = 0
        missing_position_count = 0
        same_variant_count = 0
        both_reference_count=0
        for position in variable_positions_in_at_least_one_cluster:
            try:
                if cluster1.allele_representation_dict[position] != cluster2.allele_representation_dict[position]:
                    # both are non reference but they differ
                    non_equal_position_count += 1
                elif cluster1.allele_representation_dict[position] == cluster2.allele_representation_dict[position]:
                    # both are non reference but same base do nothing
                    same_variant_count +=1
                else:
                    print 'funky'
            except KeyError:
                # one base is reference the other not
                if dont_count_missing:
                    if position in cluster1.missing_postitions or position in cluster2.missing_postitions:
                        missing_position_count+=1
                    elif position not in cluster1.allele_representation_dict and position not in cluster2.allele_representation_dict:
                        both_reference_count +=1
                    else:
                        non_equal_position_count += 1
                else: non_equal_position_count += 1
        assert len(variable_positions_in_at_least_one_cluster) == sum([non_equal_position_count,missing_position_count,same_variant_count,both_reference_count])
        #print 'comparing cluster=',cluster1.id,'vs cluster=',cluster2.id,'out of',len(variable_positions_in_at_least_one_cluster),'non reference positions in any of the clusters there are:','differences=',non_equal_position_count,'missingdata=',missing_position_count,'same_non_ref_base=',same_variant_count
        #print 'comparing cluster=',cluster1.id,'vs cluster=',cluster2.id,'out of',len(variable_positions_in_at_least_one_cluster),'non ref. pos. in any of the clusters there are:','differences=',misc.percentage(non_equal_position_count,len(variable_positions_in_at_least_one_cluster)),'missingdata=',misc.percentage(missing_position_count,len(variable_positions_in_at_least_one_cluster)),'same_base=',misc.percentage(same_variant_count+both_reference_count,len(variable_positions_in_at_least_one_cluster))

        
        percentage_difference = misc.percentage(non_equal_position_count,len(variable_positions_in_at_least_one_cluster))
        #print percentage_difference,'% difference between the variable positions in the allele representation of the two clusters '+str(cluster1.id)+' and '+str(cluster2.id)+' (',non_equal_position_count,'out of',len(variable_positions_in_at_least_one_cluster),' variable positions are different).'
        
        return len(variable_positions_in_at_least_one_cluster), non_equal_position_count, missing_position_count, same_variant_count,both_reference_count

    def find_support_for_alleles(self,):
        """ Now with this function we try to finding the clusters which have similarity with defined main alleles for covering the clusters with shortage of information in regions """ 
        import misc
       
        self.analysisfolder.database.getConnection()
        rc = len(self.analysisfolder.database.c.execute('SELECT id FROM reads').fetchall())
        tmp_read_counts = sum([i[0] for i in self.analysisfolder.database.c.execute('SELECT clusterTotalReadCount FROM barcodeClusters').fetchall()])

        print len(self.analysisfolder.database.c.execute('SELECT clusterId FROM barcodeClusters').fetchall()),' clusters in total with',tmp_read_counts,' reads out of ',rc,'reads in total',misc.percentage(tmp_read_counts,rc),'%'
        
        not_singletons_clusters = int(self.analysisfolder.results.barcodeClusterCount-self.analysisfolder.results.singeltonBarcodeClusters)
        print not_singletons_clusters,'clusters are not singletons and',tmp_read_counts-self.analysisfolder.results.singeltonBarcodeClusters,' reads out of ',rc,'reads in total',misc.percentage(tmp_read_counts-self.analysisfolder.results.singeltonBarcodeClusters,rc),'%'
        
        high_quality_cluster_ids = self.analysisfolder.database.c.execute('SELECT clusterId FROM barcodeClusters WHERE hetrozygous_positions=0 AND high_quality_cluster=1').fetchall()
        tmp_read_counts = self.analysisfolder.database.c.execute('SELECT clusterTotalReadCount FROM barcodeClusters WHERE hetrozygous_positions=0 AND high_quality_cluster=1').fetchall()
        assert len(self.high_qualitty_cluster_ids) == len(high_quality_cluster_ids)
        tmp_read_counts = sum([i[0] for i in tmp_read_counts])
        print len(high_quality_cluster_ids),' clusters have no missing data and are not hetrozygous',misc.percentage(tmp_read_counts,rc),'% of total reads'

        cluster_ids_not_hetro_with_missing = self.analysisfolder.database.c.execute('SELECT clusterId FROM barcodeClusters WHERE hetrozygous_positions<=0 AND high_quality_cluster=0').fetchall()
        tmp_read_counts = self.analysisfolder.database.c.execute('SELECT clusterTotalReadCount FROM barcodeClusters WHERE hetrozygous_positions<=0 AND high_quality_cluster=0').fetchall()
        tmp_read_counts = sum([i[0] for i in tmp_read_counts])
        print len(cluster_ids_not_hetro_with_missing),' clusters with missing data and no hetrozygous',misc.percentage(tmp_read_counts,rc),'% of total reads'

        cluster_ids_with_hetro_with_missing = self.analysisfolder.database.c.execute('SELECT clusterId FROM barcodeClusters WHERE hetrozygous_positions>=1 AND high_quality_cluster=0').fetchall()
        tmp_read_counts = self.analysisfolder.database.c.execute('SELECT clusterTotalReadCount FROM barcodeClusters WHERE hetrozygous_positions>=1 AND high_quality_cluster=0').fetchall()
        tmp_read_counts = sum([i[0] for i in tmp_read_counts])
        print len(cluster_ids_with_hetro_with_missing),' clusters with missing data and are hetrozygous',misc.percentage(tmp_read_counts,rc),'% of total reads'

        cluster_ids_with_hetro_not_missing = self.analysisfolder.database.c.execute('SELECT clusterId FROM barcodeClusters WHERE hetrozygous_positions>=1 AND high_quality_cluster=1').fetchall()
        tmp_read_counts = self.analysisfolder.database.c.execute('SELECT clusterTotalReadCount FROM barcodeClusters WHERE hetrozygous_positions>=1 AND high_quality_cluster=1').fetchall()
        tmp_read_counts = sum([i[0] for i in tmp_read_counts])
        print len(cluster_ids_with_hetro_not_missing),' clusters have no missing data but are hetrozygous',misc.percentage(tmp_read_counts,rc),'% of total reads'
        
        tmp_sum = 0
        for allele_cluster in self.allele_clusters.values():
            allele_cluster_sum = 0
            for barcode_cluster in allele_cluster['barcode_clusters_in_this_allele_cluster']:
                tmp_sum += barcode_cluster.readPairCount
                allele_cluster_sum += barcode_cluster.readPairCount
            print 'allele cluster =',allele_cluster['id'],'has',misc.percentage(allele_cluster_sum,rc),'% of the total read count'
        print 'a total of ',misc.percentage(tmp_sum,rc),'% of the reads are in the alleles'
        
        for allele_cluster in self.allele_clusters.values():allele_cluster['supporting_barcode_clusters'] = []

        #
        # TEST THING MAYBE FIX MAYBE REMOVE
        # cluster_ids_not_hetro_with_missing += self.add_hetrozygous_with_missing_clusters()
        #


        p = misc.Progress(len(cluster_ids_not_hetro_with_missing),unit='clusters')
        cluster_junk = []
        print "comparing barcode clusters to allele_clusters with missing data but not hetrozygous positions"
        for barcode_cluster_id in cluster_ids_not_hetro_with_missing:
            import seqdata
            if type(barcode_cluster_id) != int: barcode_cluster_id = barcode_cluster_id[0]
            barcode_cluster = seqdata.BarcodeCluster(barcode_cluster_id,self.analysisfolder)
            barcode_cluster.loadClusterInfo()
            #print 'cluster',barcode_cluster.id,'has',barcode_cluster.readPairCount,'read pairs'
            if barcode_cluster.readPairCount < 10:
                #print 'cluster',barcode_cluster.id,'has to few reads'
                cluster_junk.append(barcode_cluster)
                p.update()
                continue
            self.build_allele_representation_dict_for_cluster(barcode_cluster,reanalyze=False)
            matchin_count = 0
            matchin_id=None
            for allele_cluster in self.allele_clusters.values():
                cluster1=barcode_cluster
                cluster2=allele_cluster['seed_for_this_allele_cluster']['seeding_barcode_cluster']
                #print '    allelecluster=',allele_cluster['id'],'clusterrep.=',cluster2.id,
                variable_positions_count, non_equal_position_count, missing_position_count, same_variant_count, both_reference_count = self.compare_allele_representation(cluster1,cluster2,dont_count_missing=True)
                #print 'comparing cluster=',cluster1.id,'vs cluster=',cluster2.id,'out of',variable_positions_count,'non ref. pos. in any of the clusters there are:','differences=',misc.percentage(non_equal_position_count,variable_positions_count),'missingdata=',misc.percentage(missing_position_count,variable_positions_count),'same_base=',misc.percentage(same_variant_count+both_reference_count,variable_positions_count)
                if non_equal_position_count == 0 and (missing_position_count!=variable_positions_count):
                    matchin_count+=1
                    matchin_id=allele_cluster['id']
                    #print 'comparing cluster=',cluster1.id,'vs cluster=',cluster2.id,'out of',variable_positions_count,'non ref. pos. in any of the clusters there are:','differences=',misc.percentage(non_equal_position_count,variable_positions_count),'missingdata=',misc.percentage(missing_position_count,variable_positions_count),'same_non_ref_base=',misc.percentage(same_variant_count+both_reference_count,variable_positions_count)
                #else: print 'nomatch'
            if matchin_count == 1:
                #print 'THIS IS allele_cluster',matchin_id
                self.allele_clusters[matchin_id]['supporting_barcode_clusters'].append(barcode_cluster)
            else:
                cluster_junk.append(barcode_cluster)
            p.update()
                
        junk_sum = sum([barcode_cluster.readPairCount for barcode_cluster in cluster_junk])
        print len(cluster_junk),'out of',len(cluster_ids_not_hetro_with_missing),'could not be placed (',misc.percentage(len(cluster_junk),len(cluster_ids_not_hetro_with_missing)),'%)',junk_sum,'reads ie',misc.percentage(junk_sum,rc),'% of the total read count'
        for allele_cluster in self.allele_clusters.values():
            allele_cluster_sum = 0
            for barcode_cluster in allele_cluster['barcode_clusters_in_this_allele_cluster']+allele_cluster['supporting_barcode_clusters']:
                tmp_sum += barcode_cluster.readPairCount
                allele_cluster_sum += barcode_cluster.readPairCount
            print 'allele cluster =',allele_cluster['id'],'has',misc.percentage(allele_cluster_sum,rc),'% of the total read count'
        
        print 'a total of ',tmp_sum, 'which',misc.percentage(tmp_sum,rc),'% of the reads are in the alleles'
        
        total_clusters_cover_the_alleles = int(int(len(cluster_ids_not_hetro_with_missing)-len(cluster_junk))+ int(len(cluster_ids_with_hetro_not_missing)) + int(len(high_quality_cluster_ids)))
        print 'a total number of clusters that cover the reads for the alleles =',total_clusters_cover_the_alleles,'which are',misc.percentage(total_clusters_cover_the_alleles, not_singletons_clusters),'% of the total usable clusters'

    def find_individuals_id_in_clusters(self, list_of_cluster_ids):
        """ Functions find the individual's information and reports which individuals have which alleles""" 
        
        from seqdata import BarcodeCluster        
        from collections import Counter
        from misc import percentage
        import operator
        
        tmp_dictionary = {}
       
        for idnumber in list_of_cluster_ids:
            
            barcode_cluster = BarcodeCluster (idnumber, self.analysisfolder)
            barcode_cluster.loadClusterInfo()
            try: tmp_dictionary[ barcode_cluster.individual_id ] += 1
            except KeyError: tmp_dictionary[ barcode_cluster.individual_id ] = 1

        print 'Individual id information in barcode clusters:'
        print 'clusters\tid'
        for id_number, count in sorted(tmp_dictionary.iteritems(), key=operator.itemgetter(1),reverse=True):
            print str(count)+'\t'+str(id_number)
    
    def statistic_graph_report(self, genomic_position=True):
        """ Function reports the statistical result for position variation with graph visualization """
        
        import sys
        #import numpy as np
        #import pylab as P
        import matplotlib.pyplot as plt
        import misc
        #from matplotlib import rc
        #rc('mathtext', default='regular')

        tmp_position_list = self.statistic_position_info[0]
        hetrozygous_positions = self.statistic_position_info[1]
        non_reference_positions = self.statistic_position_info[2]
        missing_data_positions = self.statistic_position_info[3]
        total_clusters = self.statistic_position_info[4]
        # exon_position_list_for_hatch = self.statistic_position_info[5]
        
        if genomic_position != False:
            fig = plt.figure()
            ax1 = fig.add_subplot(111)
            y = []
            for tmp_pos in tmp_position_list:
                if missing_data_positions[tmp_pos] != 0: y.append( 100-(misc.percentage(missing_data_positions[tmp_pos],total_clusters)) )
                else: y.append( 0 )
            
            # y_for_exon_hatch = []
            # for tmp_pos_hatch in exon_position_list_for_hatch:
            #     if missing_data_positions[tmp_pos_hatch] != 0: y_for_exon_hatch.append( 100-(misc.percentage(missing_data_positions[tmp_pos_hatch],total_clusters)) )
            #     else: y_for_exon_hatch.append( 0 )
            
            ax1.plot(tmp_position_list, y, '-', label = 'coverage',color="green")
            ax1.fill_between(tmp_position_list,y, color="green", alpha=0.5)
            
            # ax1.fill_between(exon_position_list_for_hatch, y_for_exon_hatch, color="none", hatch="//", edgecolor="b", linewidth=0.0)
            
            ax1.plot( tmp_position_list, [misc.percentage(non_reference_positions[tmp_pos],total_clusters) for tmp_pos in tmp_position_list], '-', label = 'non-ref')
            twoaxis = False
            if twoaxis:
                ax2 = ax1.twinx()
                ax2.plot( tmp_position_list, [misc.percentage(hetrozygous_positions[tmp_pos],total_clusters) for tmp_pos in tmp_position_list], '-r', label = 'hetro')
            else:
                ax1.plot( tmp_position_list, [misc.percentage(hetrozygous_positions[tmp_pos],total_clusters) for tmp_pos in tmp_position_list], '-r', label = 'hetro')
        else:
            fig = plt.figure()
            ax1 = fig.add_subplot(111)
            y = []
            for tmp_pos in tmp_position_list:
                if missing_data_positions[tmp_pos] != 0: y.append( 100-(misc.percentage(missing_data_positions[tmp_pos],total_clusters)) )
                else: y.append( 0 )
            ax1.plot(range(len(tmp_position_list)), y, '-', label = 'coverage',color="green")
            ax1.fill_between(range(len(tmp_position_list)),y, color="green",alpha=0.5)
            #ax1.fill_between(range(80,150),y, color="none", hatch="//", edgecolor="b", linewidth=0.0)
            
            ax1.plot( range(len(tmp_position_list)), [misc.percentage(non_reference_positions[tmp_pos],total_clusters) for tmp_pos in tmp_position_list], '-', label = 'non-ref')
            twoaxis = False
            if twoaxis:
                ax2 = ax1.twinx()
                ax2.plot( range(len(tmp_position_list)), [misc.percentage(hetrozygous_positions[tmp_pos],total_clusters) for tmp_pos in tmp_position_list], '-r', label = 'hetro')
            else:
                ax1.plot(range(len(tmp_position_list)), [misc.percentage(hetrozygous_positions[tmp_pos],total_clusters) for tmp_pos in tmp_position_list], '-r', label = 'hetro')
        
    
        ax1.legend(loc='center left', bbox_to_anchor=(1, 0.5))
        ax1.grid()
        ax1.set_xlabel('HLA-A Sequence Position')
        ax1.set_ylabel('Percentage')
        if twoaxis:
            ax2.set_ylabel('Percentage')
            ax2.legend(loc='center left', bbox_to_anchor=(1, 0.5))
            ax2.set_ylim(0,15)
        ax1.set_ylim(0, 100)
        plt.show()
        
        
        ##### As a alternative for other type of plot graph
        # if genomic_position:
        #     y = []
        #     for tmp_pos in tmp_position_list:
        #         if missing_data_positions[tmp_pos] != 0: y.append( 100-(misc.percentage(missing_data_positions[tmp_pos],total_clusters)) )
        #         else: y.append( 0 )
        #         
        #     plt.stackplot( tmp_position_list, y, colors=['green','green'],alpha=0.2)
        #     
        #     plt.stackplot( tmp_position_list, [misc.percentage(non_reference_positions[tmp_pos],total_clusters)
        #                                        for tmp_pos in tmp_position_list], colors=['blue','blue'],alpha=0.8)
        #     
        #     plt.stackplot( tmp_position_list, [misc.percentage(hetrozygous_positions[tmp_pos],total_clusters)
        #                                        for tmp_pos in tmp_position_list], colors=['red','red'],alpha=0.6)
        # else:
        #     plt.stackplot( range(len(tmp_position_list)), [100-(misc.percentage(missing_data_positions[tmp_pos],total_clusters))
        #                                                    for tmp_pos in tmp_position_list], colors=['green','green'],alpha=0.2)
        #     
        #     plt.stackplot( range(len(tmp_position_list)), [misc.percentage(non_reference_positions[tmp_pos],total_clusters)
        #                                                    for tmp_pos in tmp_position_list], colors=['blue','blue'],alpha=0.8)
        #     
        #     plt.stackplot( range(len(tmp_position_list)), [misc.percentage(hetrozygous_positions[tmp_pos],total_clusters)
        #                                                    for tmp_pos in tmp_position_list], colors=['red','red'],alpha=0.6)
        # 
        # plt.xlabel('HLA-A Sequence Position')
        # plt.ylabel('Percentage')
        # plt.ylabel('Percentage')
        # plt.title('Individual position Info')
        # plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
        # plt.show()
        
        return 0

    def add_high_quality_heterozygous_clusters(self, ):
        
        self.junkclusters = []
        
        self.analysisfolder.database.getConnection()
        cluster_ids_with_hetro_not_missing = self.analysisfolder.database.c.execute('SELECT clusterId FROM barcodeClusters WHERE hetrozygous_positions>=1 AND high_quality_cluster=1').fetchall()
        from seqdata import BarcodeCluster
        
        tmp_position_list = self.statistic_position_info[0]
        hetrozygous_positions = self.statistic_position_info[1]
        non_reference_positions = self.statistic_position_info[2]
        missing_data_positions = self.statistic_position_info[3]
        total_clusters = self.statistic_position_info[4]
        
        from misc import percentage
        non_reference_positions_dict = {}
        for i in range(len(tmp_position_list)):
            this_position = tmp_position_list[i]
            number_non_reference_clusters_in_this_position = non_reference_positions[this_position]
            
            number_of_clusters_has_data_in_this_position = total_clusters - missing_data_positions[this_position]
            percenteage_non_ref_clusters_in_this_position = percentage(number_non_reference_clusters_in_this_position,number_of_clusters_has_data_in_this_position)
            
            if percenteage_non_ref_clusters_in_this_position >= 10:
                non_reference_positions_dict[this_position] = percenteage_non_ref_clusters_in_this_position
         
        for idnumber in cluster_ids_with_hetro_not_missing:
            
            idnumber = int(idnumber[0])
            
            cluster = BarcodeCluster(idnumber, self.analysisfolder)
            cluster.loadClusterInfo()
            
            #print cluster.id
            tmp_flag = False
            for entry in cluster.targetInfo:
                for position, bases in entry['hetrozygous_positions'].iteritems():
                    #print '    position',position,
                    if position in non_reference_positions_dict:
                        #print 'overlaps with non ref position'
                        tmp_flag = True
                    else:
                        pass#print 'do not overlap with non ref position! :) check next!'
            
            if tmp_flag:
                self.junkclusters.append(cluster)
                #print '    im a junk cluster'
            else:
                self.high_qualitty_barcode_clusters.append(cluster)
                #print '    im a nice and good cluster'
        pass

    def add_hetrozygous_with_missing_clusters(self, ):
        """ everything have a wrong name in this function we will fix it later :) """
        
        self.junkclusters = []
        ids_to_out = []
        
        self.analysisfolder.database.getConnection()
        cluster_ids_with_hetro_missing = self.analysisfolder.database.c.execute('SELECT clusterId FROM barcodeClusters WHERE hetrozygous_positions>=1 AND high_quality_cluster=0').fetchall()
        from seqdata import BarcodeCluster
        
        tmp_position_list = self.statistic_position_info[0]
        hetrozygous_positions = self.statistic_position_info[1]
        non_reference_positions = self.statistic_position_info[2]
        missing_data_positions = self.statistic_position_info[3]
        total_clusters = self.statistic_position_info[4]
        
        from misc import percentage
        non_reference_positions_dict = {}
        for i in range(len(tmp_position_list)):
            this_position = tmp_position_list[i]
            number_non_reference_clusters_in_this_position = non_reference_positions[this_position]
            
            number_of_clusters_has_data_in_this_position = total_clusters - missing_data_positions[this_position]
            percenteage_non_ref_clusters_in_this_position = percentage(number_non_reference_clusters_in_this_position,number_of_clusters_has_data_in_this_position)
            
            if percenteage_non_ref_clusters_in_this_position >= 10:
                non_reference_positions_dict[this_position] = percenteage_non_ref_clusters_in_this_position
         
        for idnumber in cluster_ids_with_hetro_missing:
            
            idnumber = int(idnumber[0])
            
            cluster = BarcodeCluster(idnumber, self.analysisfolder)
            cluster.loadClusterInfo()
            
            #print cluster.id
            tmp_flag = False
            for entry in cluster.targetInfo:
                for position, bases in entry['hetrozygous_positions'].iteritems():
                    #print '    position',position,
                    if position in non_reference_positions_dict:
                        #print 'overlaps with non ref position'
                        tmp_flag = True
                    else:
                        pass
                        #print 'do not overlap with non ref position! :) check next!'
            
            if tmp_flag:
                self.junkclusters.append(cluster)
                #print '    im a junk cluster'
            else:
                ids_to_out.append(cluster.id)
                #print '    im a nice and good cluster'
                
        return ids_to_out

    def report(self, ):
        """ Report the machine resultes in the terminal for primary information"""
        
        #
        # import
        #
        import misc
        
        print '###### PRINTINNG THE REPORT ######'
        
        #
        # get the total readcount in the complete run
        #
        self.analysisfolder.database.getConnection()
        total_read_count = len(self.analysisfolder.database.c.execute('SELECT id FROM reads').fetchall())

        reads_in_alleles = 0
        for allele_cluster in self.allele_clusters.values():
            
            allele_cluster_sum = 0
            tmp_sum = 0
            
            for barcode_cluster in allele_cluster['barcode_clusters_in_this_allele_cluster']+allele_cluster['supporting_barcode_clusters']:
                tmp_sum += barcode_cluster.readPairCount
                allele_cluster_sum += barcode_cluster.readPairCount
            print 'allele cluster =',allele_cluster['id'],'has',misc.percentage(allele_cluster_sum,total_read_count),'% of the total read count'
            reads_in_alleles += tmp_sum
        
        print 'a total of ',misc.percentage(reads_in_alleles,total_read_count),'% of the reads are in the alleles'

        print ''
        print '######### allele clusters:\n'
        
        for allele_cluster in self.allele_clusters.values():
            print str(allele_cluster['id'])+'\tallele\t'+'\t'.join([str(position) for position in sorted(self.variable_positions_in_at_least_one_barcode_cluster)])+'\tIDs' # prints the header
            for this_allele in allele_cluster['alles_in_this_cluster'].values():
                print '|-'+str(this_allele['added_to_allele_cluster_at_iteration'])+'\t'+str(this_allele['id'])+'\t',
                for position in sorted(self.variable_positions_in_at_least_one_barcode_cluster):
                    try:
                        if position in allele_cluster['seed_for_this_allele_cluster']['seeding_barcode_cluster'].allele_representation_dict and this_allele['seeding_barcode_cluster'].allele_representation_dict[position] == allele_cluster['seed_for_this_allele_cluster']['seeding_barcode_cluster'].allele_representation_dict[position]:
                            print this_allele['seeding_barcode_cluster'].allele_representation_dict[position],'\t',
                        else:
                            RED = "\033[1;91m"
                            COLOR_STOP = "\033[0m"
                            print RED+this_allele['seeding_barcode_cluster'].allele_representation_dict[position]+COLOR_STOP,'\t',
                    except KeyError:
                        print '*','\t',
                print ','.join([str(tmp_barcode_cluster.id) for tmp_barcode_cluster in this_allele['barcode_clusters']])+'\t'
            print ''
            print len(sorted([cluster.id for cluster in set(sorted(allele_cluster['barcode_clusters_in_this_allele_cluster']+allele_cluster['supporting_barcode_clusters']))])),'clusters =',
            print str(sorted([cluster.id for cluster in set(sorted(allele_cluster['barcode_clusters_in_this_allele_cluster']+allele_cluster['supporting_barcode_clusters']))]))#+'\t'+str([cluster.id for cluster in allele_cluster['supporting_barcode_clusters']])+'\t'
            
            my_id_list = [cluster.id for cluster in allele_cluster['barcode_clusters_in_this_allele_cluster']]+[cluster.id for cluster in allele_cluster['supporting_barcode_clusters']]
            print '##### Number of clusters with individual_IDs for this allele =', len(my_id_list)
            self.find_individuals_id_in_clusters( my_id_list )
            print ''

if __name__ == "__main__": main()