#! /usr/bin/env python

import sys

def main():

    import sys
    import multiprocessing
    import seqdata
    import misc

    results = Results()
    
    try:
	r1filename = sys.argv[1]
	r2filename = sys.argv[2]
	fastq_outfile1 = open(sys.argv[3]+'_R1.fastq','w')
	fastq_outfile2 = open(sys.argv[3]+'_R2.fastq','w')
	fastq_outfile3 = open(sys.argv[3]+'_Singlets.fastq','w')
	dbs_fastq = open(sys.argv[3]+'_DBS.fastq','w')
	colored_outfile = open(sys.argv[4],'w')
    except IndexError: sys.stderr.write('please supply an outfile and infiles on format:\nwfaChecker <r1> <r2> <fastq-outbase> <colored-out>\n');sys.exit()
    
    poolOfProcesses = multiprocessing.Pool(multiprocessing.cpu_count(),maxtasksperchild=100000000)
    parallelResults = poolOfProcesses.imap_unordered(foreachRead,seqdata.readPairGenerator(r1filename,r2filename),chunksize=1000)
    #parallelResults = poolOfProcesses.imap(foreachRead,readPairGenerator(sys.argv[1],sys.argv[2]),chunksize=1000)
    
    readcount = misc.bufcount(sys.argv[1])/4
    inserts = []
    insertsSizes = {}
    resultsProcessed =0
    readProcessedProgress = misc.Progress(readcount, unit='reads-processed', mem=True)
    for readpair in parallelResults:
    #for readpair in readPairGenerator(sys.argv[1],sys.argv[2]):
        #readpair = foreachRead(readpair)
        if readpair:
            #foreachRead(readpair)
            readProcessedProgress.update()
            resultsProcessed+=1
            results.add(readpair)
            colored_outfile.write( readpair.outputSeq + '\n')
            #inserts.append([readpair.id,readpair.insert])
            if readpair.insert and readpair.dbs and readpair.dbsmatch:
		dbs_fastq.write('@'+str(readpair.id)+'\n'+readpair.dbs+'\n+\n'+readpair.dbsQual+'\n')
		if readpair.insert[0] and len(readpair.insert[0]) >= 50 and readpair.insert[1] and len(readpair.insert[1]) >= 50:
		    fastq_outfile1.write( str(readpair.r1Header)+' '+str(readpair.dbs)+'\n'+str(readpair.insert[0])+'\n+\n'+str(readpair.insert[2])+'\n')
		    fastq_outfile2.write( str(readpair.r2Header)+' '+str(readpair.dbs)+'\n'+str(readpair.insert[1])+'\n+\n'+str(readpair.insert[3])+'\n')
		elif readpair.insert[0] and len(readpair.insert[0]) >= 50:
		    fastq_outfile3.write( str(readpair.r1Header)+' '+str(readpair.dbs)+'\n'+str(readpair.insert[0])+'\n+\n'+str(readpair.insert[2])+'\n')
		    try: insertsSizes[len(readpair.insert[0])] += 1
		    except KeyError: insertsSizes[len(readpair.insert[0])] = 1
		elif readpair.insert[1] and len(readpair.insert[1]) >= 50:
		    fastq_outfile3.write( str(readpair.r2Header)+' '+str(readpair.dbs)+'\n'+str(readpair.insert[1])+'\n+\n'+str(readpair.insert[3])+'\n')
		    try: insertsSizes[len(readpair.insert[1])] += 1
		    except KeyError: insertsSizes[len(readpair.insert[1])] = 1
	else: print 'HERE',readpair
    fastq_outfile1.close()
    fastq_outfile2.close()
    fastq_outfile3.close()
    dbs_fastq.close()
    colored_outfile.close()
    #print inserts
    
    results.printsummary()

def foreachRead(readpair):
    readpair.isIlluminaAdapter()
    readpair.identifyDirection()
    readpair.makeColoredOut()
    readpair.fixInsert()
    readpair.matchdbs()
    return readpair

class Results():
    
    def __init__(self, ):
        self.totalReads = 0
        self.directions = {}
        self.constructType = {}
        self.dbsmatches = {}
    
    def add(self, readpair):
        self.totalReads += 1
        try: self.directions[readpair.direction] += 1
        except KeyError: self.directions[readpair.direction] = 1
        try: self.constructType[readpair.construct] += 1
        except KeyError: self.constructType[readpair.construct] = 1
        try: self.dbsmatches[readpair.dbsmatch] += 1
        except KeyError: self.dbsmatches[readpair.dbsmatch] = 1

    def printsummary(self):
        
	import misc
	
	print '\n##### SUMMARY #####'
        
        print self.totalReads
        
        print 'Directions:'
        for direction,count in self.directions.iteritems():
            print str(direction) +'\t'+str(misc.percentage(count,self.totalReads))
        print ''
        
        print 'CunstructType:'
        for constructtype,count in self.constructType.iteritems():
            print str(constructtype) +'\t'+str(misc.percentage(count,self.totalReads))
        print ''
        
        print 'DBSmatch:'
        for match,count in self.dbsmatches.iteritems():
            if match != None: print ' '+str(match) +'\t'+str(misc.percentage(count,self.totalReads-self.dbsmatches[None]))+' (% of total-None)'
            else: print ' '+str(match) +'\t'+str(misc.percentage(count,self.totalReads))+' (% of total)'
        print ''
    
if __name__ == "__main__": main()