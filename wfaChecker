#! /usr/bin/env python

import sys

def main():

    import sys
    import multiprocessing
    import seqdata
    import misc

    results = Results()
    
    try: fasta_outfile = open(sys.argv[3],'w')
    except IndexError: sys.stderr.write('please supply an outfile and infiles on format:\nwfaChecker <r1> <r2> <fasta-out> <colored-out>\n');sys.exit()
    try: colored_outfile = open(sys.argv[4],'w')
    except IndexError: sys.stderr.write('please supply an outfile and infiles on format:\nwfaChecker <r1> <r2> <fasta-out> <colored-out>\n');sys.exit()
    
    poolOfProcesses = multiprocessing.Pool(multiprocessing.cpu_count(),maxtasksperchild=100000000)
    parallelResults = poolOfProcesses.imap_unordered(foreachRead,seqdata.readPairGenerator(sys.argv[1],sys.argv[2]),chunksize=1000)
    #parallelResults = poolOfProcesses.imap(foreachRead,readPairGenerator(sys.argv[1],sys.argv[2]),chunksize=1000)
    
    readcount = misc.bufcount(sys.argv[1])/4
    inserts = []
    insertsSizes = {}
    resultsProcessed =0
    readProcessedProgress = misc.Progress(readcount, unit='reads-processed', mem=True)
    for readpair in parallelResults:
    #for readpair in readPairGenerator(sys.argv[1],sys.argv[2]):
        #readpair = foreachRead(readpair)
        if readpair:
            #foreachRead(readpair)
            readProcessedProgress.update()
            resultsProcessed+=1
            results.add(readpair)
	    #if readpair.dbs: print readpair.dbs, readpair.dbsmatch 
            colored_outfile.write( readpair.outputSeq + '\n')
            #inserts.append([readpair.id,readpair.insert])
            if readpair.insert and len(readpair.insert) >= 50:
                fasta_outfile.write( '>'+str(readpair.id)+'\n'+str(readpair.insert)+'\n')
                try: insertsSizes[len(readpair.insert)] += 1
                except KeyError: insertsSizes[len(readpair.insert)] = 1
	else: print 'HERE',readpair
    fasta_outfile.close()
    colored_outfile.close()
    #print inserts
    
    results.printsummary()

def foreachRead(readpair):
    readpair.isIlluminaAdapter()
    readpair.identifyDirection()
    readpair.makeColoredOut()
    readpair.fixInsert()
    readpair.matchdbs()
    return readpair

class Results():
    
    def __init__(self, ):
        self.totalReads = 0
        self.directions = {}
        self.constructType = {}
        self.dbsmatches = {}
    
    def add(self, readpair):
        self.totalReads += 1
        try: self.directions[readpair.direction] += 1
        except KeyError: self.directions[readpair.direction] = 1
        try: self.constructType[readpair.construct] += 1
        except KeyError: self.constructType[readpair.construct] = 1
        try: self.dbsmatches[readpair.dbsmatch] += 1
        except KeyError: self.dbsmatches[readpair.dbsmatch] = 1

    def printsummary(self):
        
	import misc
	
	print '\n##### SUMMARY #####'
        
        print self.totalReads
        
        print 'Directions:'
        for direction,count in self.directions.iteritems():
            print str(direction) +'\t'+str(misc.percentage(count,self.totalReads))
        print ''
        
        print 'CunstructType:'
        for constructtype,count in self.constructType.iteritems():
            print str(constructtype) +'\t'+str(misc.percentage(count,self.totalReads))
        print ''
        
        print 'DBSmatch:'
        for match,count in self.dbsmatches.iteritems():
            if match != None: print ' '+str(match) +'\t'+str(misc.percentage(count,self.totalReads-self.dbsmatches[None]))+' (% of total-None)'
            else: print ' '+str(match) +'\t'+str(misc.percentage(count,self.totalReads))+' (% of total)'
        print ''
    
if __name__ == "__main__": main()